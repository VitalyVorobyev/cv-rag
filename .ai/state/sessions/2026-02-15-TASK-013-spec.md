# Task Spec: TASK-013 â€” Multi-Source Corpus Growth Architecture

**Author**: Architect
**Date**: 2026-02-15
**Priority**: high
**Effort**: large (6+ files)

## Goal

Enable corpus growth from `arxiv`, `doi`, and direct `pdf_url` references with a canonical multi-source model, explicit candidate lifecycle, append-only run artifacts, and testable ranking/update policy.

## Background

Current corpus growth flows are fragmented across seeding and ingest pathways, with limited canonical linkage between DOI/PDF discoveries and ingestion state. This task unifies discovery, resolution, queueing, ingest, and retrieval ranking around canonical `doc_id` identities and idempotent state management.

Related decision: `ADR-007` (`.ai/state/decisions/007-multi-source-corpus-growth.md`).

## Interface Contract

```python
from __future__ import annotations
from dataclasses import dataclass
from pathlib import Path
from typing import Literal

ReferenceType = Literal["arxiv", "doi", "pdf_url"]
CandidateStatus = Literal["discovered", "resolved", "ready", "ingested", "blocked", "failed"]

@dataclass(slots=True, frozen=True)
class ReferenceRecord:
    ref_type: ReferenceType
    normalized_value: str
    source_kind: str
    source_ref: str
    discovered_at_unix: int

@dataclass(slots=True, frozen=True)
class ResolvedReference:
    doc_id: str
    arxiv_id: str | None
    arxiv_id_with_version: str | None
    doi: str | None
    pdf_url: str | None
    resolution_confidence: float

@dataclass(slots=True, frozen=True)
class IngestCandidate:
    doc_id: str
    status: CandidateStatus
    best_pdf_url: str | None
    priority_score: float
    retry_count: int
    next_retry_unix: int | None

def discover_awesome_references(*, sources_path: Path, run_id: str) -> list[ReferenceRecord]:
    """Parse configured awesome repos and emit normalized reference records."""


def discover_visionbib_references(*, sources_path: Path, run_id: str) -> list[ReferenceRecord]:
    """Parse VisionBib pages and emit normalized reference records."""


def resolve_references_openalex(*, doi_refs: list[ReferenceRecord], run_id: str) -> list[ResolvedReference]:
    """Resolve DOI references to arXiv and/or OA PDF metadata using OpenAlex."""


def upsert_reference_graph(*, refs: list[ReferenceRecord], resolved: list[ResolvedReference]) -> None:
    """Idempotently merge discovery/resolution into canonical doc graph and candidate queue."""


def list_ready_candidates(*, limit: int) -> list[IngestCandidate]:
    """Return candidates ranked for ingestion."""


def ingest_candidates(*, candidates: list[IngestCandidate], force_grobid: bool = False) -> dict[str, int]:
    """Acquire fulltext, parse, chunk, embed, and index candidates."""


def mark_candidate_result(*, doc_id: str, status: CandidateStatus, reason: str | None = None) -> None:
    """Persist ingest lifecycle transitions with retry metadata."""


def compute_candidate_priority(*, source_kind: str, resolution_confidence: float, age_days: int, retry_count: int) -> float:
    """Deterministically rank candidates for ingestion queue."""


def get_provenance_boost(*, doc_id: str) -> float:
    """Return retrieval-time boost from best provenance tier for document."""
```

## File Plan

| Action | File | Description |
|--------|------|-------------|
| create | `docs/corpus-growth-design.md` | Full multi-source design and workflows |
| create | `docs/corpus-update-policy.md` | Append/upsert policy and invariants |
| create | `.ai/state/decisions/007-multi-source-corpus-growth.md` | ADR for canonical model + policy |
| create | `cv_rag/interfaces/cli/commands/corpus.py` | Additive corpus command handlers |
| modify | `cv_rag/interfaces/cli/app.py` | Wire `corpus` command group |
| modify | `cv_rag/storage/repositories.py` | Canonical dataclasses, doc_id helpers, queue scoring |
| modify | `cv_rag/storage/sqlite.py` | Canonical graph tables, events, queue lifecycle |
| modify | `cv_rag/seeding/awesome.py` | Discovery references + run artifacts + graph upsert |
| modify | `cv_rag/seeding/visionbib.py` | Discovery references + PDF/arXiv resolution hooks |
| modify | `cv_rag/seeding/openalex.py` | DOI resolution outputs + graph upsert |
| modify | `cv_rag/ingest/service.py` | Candidate ingest orchestration |
| modify | `cv_rag/ingest/pdf_pipeline.py` | `doc_id`-aware chunk/vector indexing |
| modify | `cv_rag/retrieval/hybrid.py` | Provenance score boosts |
| modify | `cv_rag/interfaces/api/schemas.py` | Include `doc_id` in API contracts |
| create | `tests/test_corpus_discovery.py` | Discovery dedupe + run artifact behavior |
| create | `tests/test_corpus_resolution.py` | DOI/arXiv/PDF resolution workflows |
| create | `tests/test_corpus_queue.py` | Candidate queue policy and retries |
| create | `tests/test_corpus_ingest_flow.py` | Candidate ingest lifecycle and url-doc indexing |
| create | `tests/test_retrieval_provenance_boost.py` | Provenance ranking effect |
| modify | `README.md` | Document corpus workflow and commands |

## Error Handling

- New domain errors:
  - `ReferenceResolutionError(CvRagError)`
  - `CandidateStateError(CvRagError)`
  - `FulltextAcquisitionError(CvRagError)`
- Resolver/network failures should create backlog transitions (`blocked`) rather than silent drop.
- Ingest candidate failures update retry counters and transition to `failed` once max retries reached.

## Testing Notes

Minimum required coverage:

- discovery dedupe and append-only run directories
- DOI -> arXiv canonical merge behavior
- DOI-only with OA PDF becomes `ready`
- DOI without fulltext becomes `blocked` with retry schedule
- candidate queue ordering and retry-limit transitions
- ingest candidate state transitions (`ready`, `blocked`, `ingested`)
- `url:` docs indexed/retrievable with `doc_id`
- provenance boost changes retrieval ordering

## Out of Scope

- Online migration from pre-existing local stores
- Breaking removal of legacy CLI commands
- Changing answer-generation prompt/routing behavior
